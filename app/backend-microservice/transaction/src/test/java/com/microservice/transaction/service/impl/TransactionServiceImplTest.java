package com.microservice.transaction.service.impl;

import com.microservice.transaction.dto.TransactionRequest;
import com.microservice.transaction.dto.TransactionResponse;
import com.microservice.transaction.model.Transaction;
import com.microservice.transaction.model.TransactionType;
import com.microservice.transaction.repository.TransactionRepository;
import com.microservice.transaction.exception.NotFoundException;
import com.microservice.transaction.exception.ValidationException;
import com.microservice.transaction.service.port.TransactionEventPublisherPort;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.ApplicationEventPublisher;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TransactionServiceImplTest {
    @Mock
    private TransactionRepository transactionRepository;
    @Mock
    private TransactionEventPublisherPort eventPublisher;
    @InjectMocks
    private TransactionServiceImpl transactionService;
    @Captor
    private ArgumentCaptor<Transaction> transactionCaptor;

    @Test
    @DisplayName("create — happy path: persists transaction, publishes event, returns response")
    void create_withValidRequest_shouldPersistAndPublishEvent() {
        String userId = "user-001";
        TransactionRequest mockRequest = mock(TransactionRequest.class);
        when(mockRequest.type()).thenReturn(TransactionType.INCOME);
        when(mockRequest.amount()).thenReturn(new BigDecimal("2500.50"));
        when(mockRequest.category()).thenReturn("Salario");
        when(mockRequest.date()).thenReturn(LocalDate.of(2026, 2, 12));
        when(mockRequest.description()).thenReturn("Pago quincenal de salario");

        Transaction mockSavedTransaction = mock(Transaction.class);
        when(mockSavedTransaction.getTransactionId()).thenReturn(42L);
        when(mockSavedTransaction.getUserId()).thenReturn("user-001");
        when(mockSavedTransaction.getType()).thenReturn(TransactionType.INCOME);
        when(mockSavedTransaction.getAmount()).thenReturn(new BigDecimal("2500.50"));
        when(mockSavedTransaction.getCategory()).thenReturn("Salario");
        when(mockSavedTransaction.getDate()).thenReturn(LocalDate.of(2026, 2, 12));
        when(mockSavedTransaction.getDescription()).thenReturn("Pago quincenal de salario");
        when(mockSavedTransaction.getCreatedAt()).thenReturn(OffsetDateTime.parse("2026-02-12T20:00:00-05:00"));

        when(transactionRepository.save(any(Transaction.class)))
                .thenReturn(mockSavedTransaction);

        TransactionResponse response = transactionService.create(userId, mockRequest);

        verify(transactionRepository).save(transactionCaptor.capture());
        Transaction savedEntity = transactionCaptor.getValue();

        assertAll("DTO to entity mapping before persistence",
                () -> assertEquals("user-001", savedEntity.getUserId(),
                        "UserId should be mapped from the request"),
                () -> assertEquals(TransactionType.INCOME, savedEntity.getType(),
                        "Transaction type should be mapped from the request"),
                () -> assertEquals(new BigDecimal("2500.50"), savedEntity.getAmount(),
                        "Amount should be mapped from the request"),
                () -> assertEquals("Salario", savedEntity.getCategory(),
                        "Category should be mapped from the request"),
                () -> assertEquals(LocalDate.of(2026, 2, 12), savedEntity.getDate(),
                        "Date should be mapped from the request"),
                () -> assertEquals("Pago quincenal de salario", savedEntity.getDescription(),
                        "Description should be mapped from the request")
        );

        verify(eventPublisher).publishCreated(mockSavedTransaction);

        assertAll("Response mapped correctly from saved entity",
                () -> assertNotNull(response,
                        "Response should not be null"),
                () -> assertEquals(42L, response.transactionId(),
                        "ID should be generated by the database"),
                () -> assertEquals("user-001", response.userId(),
                        "Response userId should match"),
                () -> assertEquals(TransactionType.INCOME, response.type(),
                        "Response type should match"),
                () -> assertEquals(new BigDecimal("2500.50"), response.amount(),
                        "Response amount should match"),
                () -> assertEquals("Salario", response.category(),
                        "Response category should match"),
                () -> assertEquals(LocalDate.of(2026, 2, 12), response.date(),
                        "Response date should match"),
                () -> assertEquals("Pago quincenal de salario", response.description(),
                        "Response description should match"),
                () -> assertEquals(OffsetDateTime.parse("2026-02-12T20:00:00-05:00"), response.createdAt(),
                        "Created timestamp should be assigned by persistence")
        );

        verifyNoMoreInteractions(transactionRepository, eventPublisher);
    }

    @Test
    @DisplayName("update — happy path: updates transaction and publishes event")
    void shouldUpdateTransactionSuccessfully_andPublishEvent() {
        String userId = "user-123";
        Long transactionId = 123L;
        TransactionRequest request = new TransactionRequest(
                TransactionType.EXPENSE,
                new BigDecimal("150.00"),
                "Alimentacion",
                LocalDate.of(2025, 3, 10),
                "Compra semanal"
        );

        Transaction existing = Transaction.builder()
                .transactionId(transactionId)
                .userId("user-123")
                .type(TransactionType.EXPENSE)
                .amount(new BigDecimal("100.00"))
                .category("Hogar")
                .date(LocalDate.of(2025, 3, 9))
                .description("Compra anterior")
                .createdAt(OffsetDateTime.parse("2025-03-09T10:00:00-05:00"))
                .build();

        Transaction saved = Transaction.builder()
                .transactionId(transactionId)
                .userId("user-123")
                .type(TransactionType.EXPENSE)
                .amount(new BigDecimal("150.00"))
                .category("Alimentacion")
                .date(LocalDate.of(2025, 3, 10))
                .description("Compra semanal")
                .createdAt(existing.getCreatedAt())
                .build();

        when(transactionRepository.findById(transactionId)).thenReturn(Optional.of(existing));
        when(transactionRepository.save(any(Transaction.class))).thenReturn(saved);

        TransactionResponse response = transactionService.updateTransaction(userId, transactionId, request);

        assertAll("Respuesta de actualizacion",
                () -> assertNotNull(response, "La respuesta no debe ser nula"),
                () -> assertEquals(transactionId, response.transactionId(), "El ID debe coincidir"),
                () -> assertEquals(new BigDecimal("150.00"), response.amount(), "El monto debe actualizarse"),
                () -> assertEquals("Alimentacion", response.category(), "La categoria debe actualizarse")
        );

        verify(transactionRepository).findById(transactionId);
        verify(transactionRepository).save(any(Transaction.class));
        verify(eventPublisher).publishUpdated(saved);
    }

    @Test
    @DisplayName("update — not found: throws NotFoundException and does not publish event")
    void shouldReturn404_whenTransactionNotFound() {
        String userId = "user-123";
        Long transactionId = 999L;
        TransactionRequest request = new TransactionRequest(
                TransactionType.EXPENSE,
                new BigDecimal("150.00"),
                "Alimentacion",
                LocalDate.of(2025, 3, 10),
                "Compra semanal"
        );

        when(transactionRepository.findById(transactionId)).thenReturn(Optional.empty());

        assertThrows(NotFoundException.class,
                () -> transactionService.updateTransaction(userId, transactionId, request),
                "Should throw NotFoundException when transaction does not exist"
        );

        verify(transactionRepository).findById(transactionId);
        verify(transactionRepository, never()).save(any(Transaction.class));
        verifyNoInteractions(eventPublisher);
    }

    @Test
    @DisplayName("update — bad request: rejects negative amount and does not publish event")
    void shouldReturn400_whenAmountIsNegative() {
        String userId = "user-123";
        TransactionRequest request = new TransactionRequest(
                TransactionType.EXPENSE,
                new BigDecimal("-10.00"),
                "Alimentacion",
                LocalDate.of(2025, 3, 10),
                "Compra semanal"
        );

        assertThrows(ValidationException.class,
                () -> transactionService.updateTransaction(userId, 123L, request),
                "Should reject negative amount"
        );

        verifyNoInteractions(transactionRepository, eventPublisher);
    }
}